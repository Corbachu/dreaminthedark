//----------------------------------------------------------------------------
//  EDGE2 Linux Misc System Code
//----------------------------------------------------------------------------
//
//  Copyright (c) 1999-2008  The EDGE2 Team.
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//----------------------------------------------------------------------------

//#include <kos.h>
//KOS_INIT_FLAGS(INIT_DEFAULT | INIT_THD_PREEMPT);

#include "i_defs.h"
//#include "i_sdlinc.h"
#include "i_net.h"

#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>

#include "../../epi/timestamp.h"

//#include "../version.h"
//#include "../con_main.h"
//#include "../dm_state.h"
//#include "../e_main.h"
//#include "../g_game.h"
//#include "../m_argv.h"
//#include "../m_misc.h"
//#include "../m_random.h"
//#include "../r_modes.h"
//#include "../w_wad.h"
//#include "../z_zone.h"

#include "dc_sysinc.h"

#include <zlib.h>

#include <kos/opts.h>
#include <kos/fs_ramdisk.h>

// FIXME: Use file_c handles
extern FILE *logfile;
extern FILE *debugfile;

#ifdef USE_FLTK

// remove some problematic #defines
#undef VISIBLE
#undef INVISIBLE

#include <FL/Fl.H>
#include <FL/Fl_Window.H>
#include <FL/fl_ask.H>

#endif // USE_FLTK

#ifndef USE_FLTK

static char cp437_to_ascii[160] =
{
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0x00 - 0x07
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0x08 - 0x0F
	'>', '<', '.', '.', '.', '.', '.', '.',   // 0x10 - 0x17
	'.', '.', '.', '<', '.', '.', 'A', 'V',   // 0x18 - 0x1F

	'.', '.', '.', '.', '.', '.', '.', '.',   // 0x80 - 0x87
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0x88 - 0x8F
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0x90 - 0x97
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0x98 - 0x9F
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0xA0 - 0xA7
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0xA8 - 0xAF

	'.', '%', '.', '|', '+', '+', '+', '.',   // 0xB0 - 0xB7
	'.', '+', '|', '+', '+', '.', '.', '+',   // 0xB8 - 0xBF
	'+', '+', '+', '+', '-', '+', '+', '|',   // 0xC0 - 0xC7
	'+', '+', '+', '+', '+', '-', '+', '-',   // 0xC8 - 0xCF
	'+', '-', '.', '.', '.', '.', '.', '+',   // 0xD0 - 0xD7
	'+', '+', '+', '.', '.', '.', '.', '.',   // 0xD8 - 0xDF

	'.', '.', '.', '.', '.', '.', '.', '.',   // 0xE0 - 0xE7
	'.', '.', '.', '.', '.', '.', '.', '.',   // 0xE8 - 0xEF
	'.', '.', '>', '<', '.', '.', '.', '.',   // 0xF0 - 0xF7
	'.', '.', '.', '.', '.', '.', '.', '.'    // 0xF8 - 0xFF
};
#endif

// cleanup handling -- killough:

static void I_SignalHandler(int s)
{
	// CPhipps - report but don't crash on SIGPIPE
	if (s == SIGPIPE)
	{
		// -AJA- linux signals reset when raised.
		signal(SIGPIPE, I_SignalHandler);

		fprintf(stderr, "EDGE2: Broken pipe\n");
		return;
	}

	signal(s, SIG_IGN);    // Ignore future instances of this signal.

	switch (s)
	{
		case SIGSEGV: I_Error("EDGE2: Segmentation Violation"); break;
		case SIGINT:  I_Error("EDGE2: Interrupted by User"); break;
		case SIGILL:  I_Error("EDGE2: Illegal Instruction"); break;
		case SIGFPE:  I_Error("EDGE2: Floating Point Exception"); break;
		case SIGABRT: I_Error("EDGE2: Aborted"); break;
		case SIGTERM: I_Error("EDGE2: Killed"); break;
	}

	I_Error("EDGE2: Terminated by signal %d", s);
}


void I_SetupSignalHandlers(bool allow_coredump)
{
	signal(SIGPIPE, I_SignalHandler); // CPhipps - add SIGPIPE, as this is fatal

	if (allow_coredump)
	{
		// -AJA- Disable signal handlers, otherwise we don't get core dumps
		//       and core dumps are _DAMN_ useful for debugging.
		return;
	}

	signal(SIGSEGV, I_SignalHandler);
	signal(SIGTERM, I_SignalHandler);
	signal(SIGILL,  I_SignalHandler);
	signal(SIGFPE,  I_SignalHandler);
	signal(SIGILL,  I_SignalHandler);
	signal(SIGINT,  I_SignalHandler);  // killough 3/6/98: allow CTRL-BRK during init
	signal(SIGABRT, I_SignalHandler);
}

void I_CheckAlreadyRunning(void)
{
  /* nothing needed */
}


void I_WaitVBL (int count)
{
}

// Most of the following has been rewritten by Lee Killough
// and then by CPhipps
//
// I_GetTime
//

// CPhipps - believe it or not, it is possible with consecutive calls to
// gettimeofday to receive times out of order, e.g you query the time twice and
// the second time is earlier than the first. Cheap'n'cheerful fix here.
// NOTE: only occurs with bad kernel drivers loaded, e.g. pc speaker drv

unsigned long I_GetMicroSec (void)
{
	struct timeval tv;
	struct timezone tz;
	gettimeofday (&tv, &tz);
	return (tv.tv_sec * 1000000 + tv.tv_usec);
}


extern int autorun;  // Autorun state


bool microtimer_installed = 1;


static char errmsg[4096];  // buffer of error message -- killough

// killough 2/22/98: Add support for ENDBOOM, which is PC-specific

// this converts BIOS color codes to ANSI codes.  Its not pretty, but it
// does the job - rain
// CPhipps - made static

static inline int convert_colour(int colour, int *bold)
{
	*bold = 0;

	if (colour > 7)
	{
		colour &= 7;
		*bold = 1;
	}

	switch (colour)
	{
		case 1: return 4;
		case 3: return 6;
		case 4: return 1;
		case 6: return 3;
	}

	return colour;
}

// CPhipps - flags controlling ENDOOM behaviour
enum
{
	endoom_colours = 1,
	endoom_nonasciichars = 2,
	endoom_droplastline = 4
};
unsigned int endoom_mode;

//
// I_Warning
//
void I_Warning(const char *warning,...)
{
	va_list argptr;

	va_start (argptr, warning);
	vsnprintf (errmsg, 4095, warning, argptr);
	va_end (argptr);

	I_Printf ("WARNING: %s", errmsg);
}

//
// I_Error
//
void I_Error(const char *error, ...)
{
	va_list argptr;

	va_start (argptr, error);
	vsnprintf (errmsg, 4095, error, argptr);
	va_end (argptr);

	if (logfile)
	{
		fprintf(logfile, "ERROR: %s\n", errmsg);
		fflush(logfile);
	}

	if (debugfile)
	{
		fprintf(debugfile, "ERROR: %s\n", errmsg);
		fflush(debugfile);
	}

	// -AJA- Commit suicide, thereby producing a core dump which may
	//       come in handy for debugging the code that called I_Error().
	//if (M_CheckParm("-core"))
	//{
	//	fprintf(stderr, "%s\n", errmsg);

	//	I_GrabCursor(false);

	//	raise(11);
		/* NOTREACHED */
	//}

	I_SystemShutdown();

	//I_MessageBox(errmsg, "EDGE2 Error");

	I_CloseProgram(-1);
}

// -AJA- Routine which emulates IBM charset.
#ifndef USE_FLTK
static void PrintString(char *str)
{
	for (; *str; str++)
	{
		int ch = (unsigned char) *str;

		if (ch == 0x7F || ch == '\r')
			continue;

		if ((0x20 <= ch && ch <= 0x7E) ||
				ch == '\n' || ch == '\t')
		{
			putchar(ch);
			continue;
		}

		if (ch >= 0x80)
			ch -= 0x60;

		putchar(cp437_to_ascii[ch]);
	}

	fflush(stdout);
}
#endif

void I_Printf(const char *message,...)
{
	va_list argptr;
	char printbuf[1024];
	char *string = printbuf;

	va_start(argptr, message);

	// Print the message into a text string
	vsnprintf(printbuf, 1023, message, argptr);

	if (logfile)
	{
		fprintf(logfile, "%s\n", errmsg);
		fflush(logfile);
	}

	if (debugfile)
	{
		fprintf(debugfile, "%s\n", errmsg);
		fflush(debugfile);
	}

	// Clean up \n\r combinations
	while (*string)
	{
		if (*string == '\n')
		{
			memmove (string + 2, string + 1, strlen (string));
			string[1] = '\r';
			string++;
		}
		string++;
	}

	// Send the message to the console.
	// CON_Printf("%s", printbuf);

	// And the text screen if in text mode
#ifndef USE_FLTK
	PrintString(printbuf);
#endif

	va_end(argptr);

	fflush(stdout);
}

void TextAttr (int attr)
{
	// Not supported in Linux without low-level termios manipulation
	// or ncurses, which I'd rather not link
	// textattr(attr);
}

void ClearScreen (void)
{
	I_Printf("\n");
}

//
// I_DisplayExitScreen
//
void I_DisplayExitScreen(void)
{
	/* not implemented */
}

//
// I_CloseProgram
//
void I_CloseProgram(int exitnum)
{
	exit(exitnum);
	//I_TraceBack();
}

//
// I_TraceBack
//
// Like I_CloseProgram, but may display some sort of debugging information
// on some systems (typically the function call stack).
void I_TraceBack(void)
{
	I_CloseProgram(-1);
}

//
// I_SystemStartup
//
// -ACB- 1998/07/11 Reformatted the code.
//
void I_SystemStartup(void)
{
	//Uint32 flags = 0;

	//if (M_CheckParm("-core"))
	//	flags |= SDL_INIT_NOPARACHUTE;

	//if (SDL_Init(flags) < 0)
	//	I_Error("Couldn't init SDL!!\n%s\n", SDL_GetError());

	//I_StartupGraphics();
	//I_StartupControl();
#ifndef NO_SOUND
	//I_StartupSound();    // -ACB- 1999/09/20 Sets nosound directly
#endif
#ifndef NO_MUSIC
	//I_StartupMusic();
#endif
#ifndef NO_NETWORK
	//I_StartupNetwork();
#endif
}

//
// I_SystemShutdown
//
// -ACB- 1998/07/11 Tidying the code
//
void I_SystemShutdown(void)
{
	// makre sure audio is unlocked (e.g. I_Error occurred)
#ifndef NO_SOUND
	//I_UnlockAudio();
#endif
#ifndef NO_NETWORK
	I_ShutdownNetwork();
#endif
#ifndef NO_MUSIC
	//I_ShutdownMusic();
#endif
#ifndef NO_SOUND
	//I_ShutdownSound();
#endif
	I_ShutdownControl();
	I_ShutdownGraphics();

	if (logfile)
	{
		fclose(logfile);
		logfile = NULL;
	}

	// -KM- 1999/01/31 Close the debugfile
	if (debugfile)
	{
		fclose(debugfile);
		debugfile = NULL;
	}
}

//
// I_PureRandom
//
// Returns as-random-as-possible 32 bit values.
//
int I_PureRandom(void)
{
	return ((int)time(NULL) ^ (int)I_ReadMicroSeconds()) & 0x7FFFFFFF;
}

//
// I_ReadMicroSeconds
//
u32_t I_ReadMicroSeconds(void)
{
	struct timeval tv;

	gettimeofday(&tv, NULL);

	return (u32_t)tv.tv_sec * 1000000 + (u32_t)tv.tv_usec;
}

//
// I_Sleep
//
void I_Sleep(int millisecs)
{
	//!!!! FIXME: use nanosleep ?
	usleep(millisecs * 1000);
}

//extern void DC_Tactile (int freq, int intensity, int select);

//
// Force Feedback
//
//void I_Tactile (int freq, int intensity, int select)
//{
//	/DC_Tactile(freq, intensity, select);
//}

#ifndef MACOSX // Defined separately under Mac OS X. -ACB- 2010/12/20
//
// I_MessageBox
//
void I_MessageBox(const char *message, const char *title)
{
#ifdef USE_FLTK
	Fl::scheme(NULL);
	fl_message_font(FL_HELVETICA /*_BOLD*/, 18);
	fl_message("%s", message);

#else // USE_FLTK
	fprintf(stderr, "\n%s\n", message);
#endif // USE_FLTK
}
#endif // !MACOSX

//
// VMU support code
//

// 32x32 16 color, preceded by the palette
unsigned char cacodemon_icon[544] = {
	0x17, 0xf1,
	0x10, 0xf7,
	0x00, 0xfb,
	0x22, 0xf5,
	0x00, 0xfd,
	0x33, 0xf3,
	0x20, 0xf9,
	0x43, 0xf6,
	0x32, 0xf9,
	0x51, 0xf3,
	0x55, 0xf9,
	0x66, 0xf6,
	0x55, 0xff,
	0x99, 0xf9,
	0xcc, 0xfd,
	0xff, 0xff,
	0xff, 0xfe, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xed, 0xff, 0xff, 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0xff, 0xfe, 0xde, 0xff,
	0xff, 0xfd, 0xef, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 0xff, 0xfe, 0xdf, 0xff,
	0xff, 0xfe, 0xbe, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 0xff, 0xed, 0xdf, 0xff,
	0xff, 0xff, 0xbd, 0xef, 0xdb, 0xde, 0xee, 0x24, 0x48, 0xee, 0xed, 0xdd, 0xfe, 0xbb, 0xff, 0xff,
	0xff, 0xff, 0xeb, 0xbe, 0xb1, 0x22, 0x84, 0x44, 0x44, 0x48, 0x22, 0x1b, 0xdd, 0xbe, 0xff, 0xff,
	0xfe, 0xff, 0xfb, 0xbd, 0xed, 0x24, 0x24, 0x44, 0x44, 0x44, 0x26, 0xed, 0xdb, 0xbf, 0xff, 0xef,
	0xfd, 0xdf, 0xe8, 0x5b, 0xbe, 0xa4, 0x26, 0x42, 0x42, 0x62, 0x4a, 0xeb, 0xb5, 0x8e, 0xfd, 0xdf,
	0xff, 0xdd, 0xd8, 0x23, 0xbb, 0xa4, 0x22, 0x24, 0x22, 0x42, 0x4a, 0xbb, 0xa2, 0x8d, 0xdd, 0xff,
	0xff, 0xeb, 0xbb, 0x22, 0x66, 0x22, 0x42, 0x21, 0x66, 0x24, 0x22, 0x16, 0x22, 0x7b, 0xbe, 0xff,
	0xff, 0xa4, 0x22, 0x26, 0x66, 0x22, 0x44, 0x21, 0x12, 0x44, 0x22, 0x21, 0x22, 0x22, 0x4a, 0xff,
	0xfd, 0x22, 0x22, 0x22, 0x11, 0x66, 0x24, 0x42, 0x24, 0x42, 0x21, 0x61, 0x62, 0x22, 0x22, 0xdf,
	0xfa, 0x62, 0x24, 0x26, 0x66, 0x66, 0x11, 0x26, 0x26, 0x11, 0x66, 0x66, 0x64, 0x22, 0x26, 0xaf,
	0xfa, 0x16, 0x66, 0x62, 0x26, 0x66, 0x63, 0x99, 0x99, 0x36, 0x66, 0x62, 0x26, 0x62, 0x11, 0xaf,
	0xe4, 0x21, 0x16, 0x6c, 0xc6, 0x66, 0x66, 0x99, 0x99, 0x66, 0x66, 0x6c, 0xc8, 0x61, 0x16, 0x4e,
	0x22, 0x11, 0x11, 0xc8, 0xcc, 0xc6, 0x66, 0x11, 0x76, 0x66, 0x6c, 0xcc, 0x86, 0x13, 0x16, 0x22,
	0x26, 0x66, 0x77, 0x66, 0xcc, 0xcc, 0x2c, 0x26, 0x66, 0xc4, 0xcc, 0xcc, 0x66, 0x77, 0x16, 0x62,
	0x16, 0x63, 0x5b, 0x76, 0x6c, 0xcc, 0x8a, 0xec, 0xcc, 0xda, 0xcc, 0xc6, 0x17, 0xb3, 0x11, 0x11,
	0x16, 0x63, 0x55, 0xb7, 0x16, 0x6c, 0xcc, 0xcc, 0xce, 0xcc, 0xc6, 0x61, 0x7b, 0x51, 0x11, 0x11,
	0x14, 0x6b, 0x95, 0xb7, 0xb8, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0x61, 0x7b, 0x75, 0x13, 0xb6, 0x26,
	0xe2, 0x46, 0x13, 0x55, 0x5b, 0xb1, 0x36, 0x66, 0x62, 0x61, 0x7b, 0x75, 0x05, 0x16, 0x14, 0x2e,
	0xe1, 0x44, 0x1b, 0xb5, 0x05, 0xbb, 0xb7, 0x37, 0x73, 0x77, 0xb7, 0x55, 0x1b, 0xb8, 0x44, 0x8e,
	0xfa, 0x66, 0x28, 0x56, 0x10, 0x5d, 0xb0, 0x0b, 0xd0, 0x0b, 0xd5, 0x11, 0x67, 0x12, 0x62, 0xaf,
	0xfd, 0x66, 0x22, 0x22, 0x11, 0x5d, 0xb0, 0x05, 0xb0, 0x0b, 0xd3, 0x61, 0x62, 0x22, 0x26, 0xdf,
	0xfb, 0x16, 0xc6, 0x24, 0x2a, 0x3b, 0xb8, 0xd8, 0x1d, 0x1b, 0xb7, 0x34, 0x44, 0x62, 0x21, 0xbf,
	0xfa, 0xbb, 0x66, 0x62, 0x44, 0x21, 0x12, 0x84, 0x48, 0x26, 0x34, 0x44, 0x26, 0x66, 0x7b, 0xaf,
	0xfe, 0x83, 0x62, 0x26, 0x22, 0x42, 0x42, 0x44, 0x44, 0x24, 0x24, 0x26, 0x62, 0x26, 0x38, 0xef,
	0xff, 0xee, 0xdb, 0x22, 0x22, 0x62, 0x26, 0x22, 0x22, 0x62, 0x46, 0x64, 0x22, 0xbd, 0xee, 0xff,
	0xff, 0xff, 0xbb, 0x82, 0x23, 0x22, 0x22, 0x12, 0x21, 0x22, 0x26, 0x32, 0x28, 0xbb, 0xff, 0xff,
	0xff, 0xff, 0xbf, 0xee, 0x83, 0xb3, 0xbb, 0x12, 0x61, 0x7b, 0x3b, 0x3c, 0xee, 0xed, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfb, 0xbb, 0x17, 0x5a, 0x8b, 0x51, 0xbb, 0xbe, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xed, 0xe3, 0xaf, 0xfa, 0x1d, 0xee, 0xff, 0xff, 0xff, 0xff, 0xff,
};

unsigned char marine_icon[544] = {
	0x00, 0xf0,
	0x20, 0xf2,
	0x31, 0xf4,
	0x31, 0xf5,
	0x42, 0xf6,
	0x52, 0xf8,
	0x50, 0xf9,
	0x63, 0xf9,
	0x64, 0xfa,
	0x86, 0xf9,
	0x74, 0xfc,
	0x85, 0xfd,
	0x99, 0xf9,
	0x96, 0xfe,
	0xb8, 0xff,
	0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xf2, 0x33, 0x34, 0x44, 0x44, 0x44, 0x33, 0x2f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xf1, 0x33, 0x55, 0x8a, 0xab, 0xaa, 0x87, 0x43, 0x33, 0x1f, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x13, 0x45, 0x8a, 0xaa, 0xa8, 0x77, 0x75, 0x74, 0x43, 0x21, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x14, 0x54, 0x57, 0x85, 0x85, 0x74, 0x44, 0x43, 0x31, 0x11, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x23, 0x43, 0x57, 0x55, 0x55, 0x27, 0x32, 0x32, 0x11, 0x11, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x12, 0x33, 0x53, 0x74, 0x45, 0x42, 0x42, 0x23, 0x11, 0x11, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x22, 0x44, 0x35, 0x34, 0x44, 0x45, 0x55, 0x54, 0x42, 0x12, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x23, 0x45, 0x43, 0x73, 0x45, 0x88, 0x78, 0x55, 0x54, 0x22, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x23, 0x78, 0x88, 0x88, 0xa8, 0x8a, 0x87, 0x88, 0x85, 0x22, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x24, 0x7b, 0xaa, 0x87, 0x88, 0x88, 0x88, 0xaa, 0xb7, 0x32, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x24, 0x7a, 0xdd, 0xba, 0x85, 0x58, 0xab, 0xde, 0xa7, 0x42, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xf1, 0x24, 0x10, 0x37, 0xbd, 0xbb, 0xba, 0xdd, 0xee, 0xd8, 0x42, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0x84, 0x24, 0x54, 0x10, 0x7e, 0x8d, 0xe8, 0xeb, 0x72, 0x12, 0x42, 0x48, 0xff, 0xff,
	0xff, 0xff, 0x84, 0x25, 0x84, 0x10, 0x00, 0x38, 0x83, 0x02, 0x12, 0x35, 0x82, 0x48, 0xff, 0xff,
	0xff, 0xff, 0x54, 0x3a, 0x40, 0x0c, 0x90, 0x23, 0x32, 0x00, 0x0c, 0xc4, 0x83, 0x45, 0xff, 0xff,
	0xff, 0xff, 0x43, 0x58, 0x58, 0xd7, 0x23, 0x5b, 0xa5, 0x34, 0x8d, 0x75, 0x85, 0x34, 0xff, 0xff,
	0xff, 0xff, 0x53, 0x5b, 0xb8, 0x87, 0x8a, 0x7e, 0xe8, 0xa8, 0x58, 0x8b, 0xb5, 0x35, 0xff, 0xff,
	0xff, 0xff, 0x53, 0x5b, 0xde, 0xba, 0xde, 0xde, 0xed, 0xed, 0xad, 0xdd, 0xa5, 0x35, 0xff, 0xff,
	0xff, 0xff, 0xf3, 0x57, 0x88, 0xbd, 0xed, 0xbd, 0xfb, 0xde, 0xdb, 0x88, 0x75, 0x3f, 0xff, 0xff,
	0xff, 0xff, 0xf3, 0x47, 0x8a, 0xee, 0xa8, 0x79, 0x75, 0x8b, 0xee, 0xa7, 0x74, 0x3f, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x48, 0x5b, 0xed, 0x83, 0x45, 0x54, 0x27, 0xde, 0xb7, 0xa4, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x3a, 0x7d, 0xe8, 0xad, 0xa7, 0x8a, 0xda, 0x8e, 0xd5, 0xa3, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x38, 0x7a, 0xdb, 0xbe, 0xeb, 0xbe, 0xeb, 0xbd, 0xb8, 0x83, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xf5, 0x8a, 0xb5, 0x46, 0x67, 0x66, 0x64, 0x5b, 0xa8, 0x4f, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xf3, 0x58, 0xaa, 0xab, 0xdd, 0xdd, 0xba, 0xaa, 0x85, 0x3f, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x47, 0xab, 0xa8, 0x55, 0x55, 0x8a, 0xba, 0x74, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xf4, 0x8a, 0xba, 0xab, 0xda, 0xab, 0xb8, 0x4f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0x35, 0x8b, 0xde, 0xed, 0xb8, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0x77, 0x77, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

unsigned char pentagram_icon[544] = {
	0x00, 0xf0,
	0x10, 0xf2,
	0x10, 0xf4,
	0x10, 0xf7,
	0x41, 0xf7,
	0x31, 0xfb,
	0x31, 0xfa,
	0x54, 0xf7,
	0x63, 0xfd,
	0x76, 0xfb,
	0x99, 0xf9,
	0x84, 0xfe,
	0xb7, 0xff,
	0xcc, 0xfc,
	0xdd, 0xfd,
	0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xa7, 0x43, 0x65, 0x63, 0x9a, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xfd, 0xa3, 0x66, 0x88, 0x8b, 0x88, 0x85, 0x59, 0xdf, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x98, 0x88, 0x83, 0x10, 0x00, 0x02, 0x38, 0x88, 0x89, 0xef, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xeb, 0x8b, 0x61, 0x03, 0x60, 0x10, 0x01, 0x20, 0x38, 0xbb, 0x9d, 0xff, 0xff, 0xff,
	0xff, 0xfe, 0x9b, 0xcb, 0x20, 0x13, 0x33, 0x00, 0x00, 0x13, 0x4b, 0xcc, 0x86, 0xdf, 0xff, 0xff,
	0xff, 0xf9, 0x8b, 0xcc, 0xb6, 0x33, 0x26, 0x10, 0x21, 0x11, 0xbc, 0xb7, 0xb8, 0x4d, 0xff, 0xff,
	0xff, 0xa8, 0xb4, 0xbb, 0xcb, 0xb5, 0x33, 0x30, 0x60, 0x4c, 0x8c, 0x83, 0x3b, 0x89, 0xef, 0xff,
	0xfd, 0x6b, 0x40, 0x6c, 0x68, 0xb6, 0x33, 0x52, 0x05, 0xb6, 0x8b, 0x65, 0x52, 0xb6, 0xae, 0xff,
	0xf9, 0x86, 0x02, 0x4b, 0x63, 0x38, 0x83, 0x32, 0x58, 0x33, 0xbb, 0x41, 0x35, 0x68, 0x7d, 0xff,
	0xe4, 0x83, 0x60, 0x04, 0x81, 0x13, 0x58, 0x56, 0x63, 0x22, 0xb8, 0x01, 0x03, 0x36, 0x5a, 0xef,
	0xa6, 0x63, 0x10, 0x00, 0x85, 0x36, 0x25, 0x85, 0x52, 0x53, 0x84, 0x03, 0x01, 0x36, 0x67, 0xdf,
	0x96, 0x33, 0x00, 0x23, 0x35, 0x23, 0x28, 0x85, 0x85, 0x53, 0x60, 0x32, 0x03, 0x33, 0x82, 0xdf,
	0x78, 0x23, 0x33, 0x02, 0x36, 0x35, 0x85, 0x12, 0x66, 0x85, 0x52, 0x20, 0x30, 0x33, 0x83, 0xae,
	0x28, 0x02, 0x26, 0x20, 0x38, 0x58, 0x55, 0x12, 0x31, 0x58, 0x80, 0x32, 0x10, 0x61, 0x86, 0xae,
	0x58, 0x13, 0x01, 0x35, 0xb5, 0x83, 0x15, 0x22, 0x51, 0x25, 0x88, 0x22, 0x23, 0x51, 0x88, 0xad,
	0x88, 0x02, 0x10, 0x68, 0x23, 0x52, 0x32, 0x32, 0x16, 0x06, 0x83, 0xb8, 0x53, 0x22, 0x85, 0xae,
	0x38, 0x02, 0x26, 0x82, 0x35, 0x85, 0x32, 0x66, 0x26, 0x38, 0x56, 0x3b, 0xb4, 0x33, 0x83, 0x7d,
	0x98, 0x26, 0x86, 0x25, 0x10, 0x58, 0x35, 0x65, 0x53, 0x65, 0x13, 0x54, 0x4b, 0xc6, 0x83, 0xae,
	0x9b, 0xbc, 0x55, 0x65, 0x56, 0x36, 0x55, 0x63, 0x35, 0x85, 0x58, 0x88, 0x8b, 0xbc, 0xb2, 0xae,
	0x9b, 0xc8, 0x88, 0x68, 0x66, 0x58, 0x85, 0x36, 0x58, 0x85, 0x8b, 0xbb, 0xbb, 0xbc, 0xb7, 0xae,
	0xe8, 0xb4, 0x52, 0x00, 0x10, 0x35, 0x88, 0x8b, 0x88, 0x30, 0x25, 0x12, 0x01, 0x48, 0x67, 0xde,
	0xf9, 0x86, 0x26, 0x53, 0x12, 0x03, 0xb8, 0x23, 0x5c, 0x50, 0x00, 0x02, 0x11, 0x38, 0x2a, 0xdf,
	0xfd, 0x66, 0x35, 0x32, 0x53, 0x13, 0x88, 0x21, 0x88, 0x23, 0x00, 0x00, 0x02, 0x84, 0x7a, 0xef,
	0xff, 0x98, 0x82, 0x05, 0xb6, 0x36, 0x4b, 0x68, 0xc1, 0x35, 0x10, 0x12, 0x13, 0x61, 0xad, 0xff,
	0xff, 0xe9, 0x56, 0x33, 0x82, 0x12, 0x2b, 0x88, 0xb6, 0x00, 0x22, 0x61, 0x38, 0x77, 0xde, 0xff,
	0xff, 0xfd, 0x76, 0x63, 0x53, 0x33, 0x0b, 0xbb, 0x42, 0x32, 0x30, 0x28, 0x62, 0x7a, 0xef, 0xff,
	0xff, 0xff, 0xd7, 0x66, 0x81, 0x05, 0x24, 0xcb, 0x30, 0x05, 0x23, 0x83, 0x77, 0xad, 0xff, 0xff,
	0xff, 0xff, 0xfd, 0x73, 0x88, 0x66, 0x64, 0xcb, 0x43, 0x66, 0x88, 0x30, 0x7a, 0xdf, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xea, 0x72, 0x66, 0x8b, 0xcc, 0xb8, 0x86, 0x37, 0x7a, 0xde, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xfe, 0xda, 0x77, 0x26, 0x88, 0x53, 0x71, 0x7a, 0xad, 0xef, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xda, 0xaa, 0xaa, 0xaa, 0xaa, 0xdd, 0xef, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed, 0xdd, 0xdd, 0xee, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
};

/* int DC_LoadFromVMU(char *dst)
{
    char src[32];
    char dest[28];
    int file;
    int filesize;
    uint32 unzipsize;
    uint8* data;
    uint8* unzipdata;
    vmu_pkg_t pkg;

    strcpy(src, "/vmu/a1/");
    strcat(src, dst);
    strcpy(dest, "/ram/");
    strcat(dest, dst);

    // get compressed file from VMU
    file = fs_open(src, O_RDONLY);
    if(!file)
		return -1;
    filesize = fs_total(file);
    if(filesize <= 0)
		return -1;
    data = (uint8*)malloc(filesize);
    fs_read(file, data, filesize);
    vmu_pkg_parse(data, &pkg);
    fs_close(file);
	// decompress
    unzipdata = (uint8 *)malloc(65536);
    unzipsize = 65536;
    uncompress(unzipdata, &unzipsize, (uint8 *)pkg.data, pkg.data_len);

	// write decompressed data to file in /ram
    fs_unlink(dest); // delete if exists
    file = fs_open(dest, O_WRONLY);
    fs_write(file, unzipdata, unzipsize);
    fs_close(file);

    free(data);
    free(unzipdata);

    return 0;
}

int DC_SaveToVMU(char *src, int ftype)
{
    char dst[32];
    file_t file;
    int filesize = 0;
    uint32 zipsize = 0;
    uint8 *data;
    uint8 *zipdata;
    vmu_pkg_t pkg;
    uint8 *pkg_out;
    int pkg_size;
    unsigned char *icon_data;

	// read uncompressed data from /ram
    strcpy(dst, "/ram/");
    strcat(dst, src);

    file = fs_open(dst, O_RDONLY);
    if (!file)
		return -1;
    filesize = fs_total(file);
    data = (uint8*)malloc(filesize);
    fs_read(file, data, filesize);
    fs_close(file);

	// compress data
    zipsize = filesize * 2;
    zipdata = (uint8*)malloc(zipsize);
    compress(zipdata, &zipsize, data, filesize);

    // fill in VMU header
    strcpy(pkg.desc_short, "DREAMDARK");
    switch(ftype)
    {
		case 0:
			strcpy(pkg.desc_long, "Game Save");
			icon_data = cacodemon_icon;
			break;
		case 1:
			strcpy(pkg.desc_long, "In-Game Settings");
			icon_data = pentagram_icon;
			break;
		case 2:
			strcpy(pkg.desc_long, "User Settings");
			icon_data = marine_icon;
			break;
		case 3:
			strcpy(pkg.desc_long, "Demo Game");
			icon_data = cacodemon_icon;
			break;
		case 4:
			strcpy(pkg.desc_long, "Screen Shot");
			icon_data = marine_icon;
			break;
		default:
			strcpy(pkg.desc_long, "Doom File");
			icon_data = pentagram_icon;
			break;
    }

    strcpy(pkg.app_id, "DREAMDARK");
    pkg.icon_cnt = 1;
    pkg.icon_anim_speed = 0;
    memcpy(&pkg.icon_pal[0], icon_data, 32);
    pkg.icon_data = icon_data + 32;
    pkg.eyecatch_type = VMUPKG_EC_NONE;
    pkg.data_len = zipsize;
    pkg.data = zipdata;
    vmu_pkg_build(&pkg, &pkg_out, &pkg_size);

	// save compressed data to VMU
    strcpy(dst, "/vmu/a1/");
    strcat(dst, src);
    fs_unlink(dst);
    file = fs_open(dst, O_WRONLY);
    fs_write(file, pkg_out, pkg_size);
    fs_close(file);

    free(pkg_out);
    free(data);
    free(zipdata);

    return 0;
} */


//--- editor settings ---
// vi:ts=4:sw=4:noexpandtab
